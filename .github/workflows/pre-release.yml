name: Pre-release Build

on:
  # Manual trigger (UI) - select platform
  workflow_dispatch:
    inputs:
      platform:
        description: 'Platform to build'
        required: true
        default: 'macos'
        type: choice
        options:
          - macos
          - linux
          - all
      sign:
        description: 'Code sign with Developer ID (requires secrets)'
        required: false
        default: false
        type: boolean
  # Auto trigger on merged PR to main (owner only)
  pull_request:
    types: [closed]
    branches: [main]

permissions:
  contents: write
  pull-requests: read

env:
  # Apple Developer Configuration (only used if sign=true or for release builds)
  APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
  APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
  SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}

jobs:
  build-macos:
    # Manual: check platform input | PR merged: owner only, build macos
    if: |
      (github.event_name == 'workflow_dispatch' && (inputs.platform == 'macos' || inputs.platform == 'all')) ||
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true && github.event.pull_request.user.login == github.repository_owner)
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: core

      # ============================================================
      # APPLE DEVELOPER CERTIFICATE SETUP (Optional)
      # ============================================================
      - name: Install Apple Developer Certificate
        if: ${{ inputs.sign == true && env.APPLE_SIGNING_IDENTITY != '' }}
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ github.run_id }}
        run: |
          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # Decode certificate from base64
          echo -n "$APPLE_CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate to keychain
          security import $CERTIFICATE_PATH -P "$APPLE_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Verify certificate
          echo "Installed certificates:"
          security find-identity -v -p codesigning $KEYCHAIN_PATH

      # ============================================================
      # BUILD
      # ============================================================
      - name: Build Rust core (universal)
        run: |
          cd core
          cargo build --release --target aarch64-apple-darwin
          cargo build --release --target x86_64-apple-darwin
          lipo -create \
            target/aarch64-apple-darwin/release/libgonhanh_core.a \
            target/x86_64-apple-darwin/release/libgonhanh_core.a \
            -output ../platforms/macos/libgonhanh_core.a

      - name: Build macOS app
        env:
          SHOULD_SIGN: ${{ inputs.sign == true && env.APPLE_SIGNING_IDENTITY != '' }}
          CODE_SIGN_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY || '-' }}
          DEVELOPMENT_TEAM: ${{ env.APPLE_TEAM_ID }}
        run: |
          cd platforms/macos

          if [ "$SHOULD_SIGN" = "true" ]; then
            echo "Building with Developer ID signing..."
            xcodebuild -scheme GoNhanh -configuration Release \
              -derivedDataPath build \
              CODE_SIGN_IDENTITY="$CODE_SIGN_IDENTITY" \
              DEVELOPMENT_TEAM="$DEVELOPMENT_TEAM" \
              CODE_SIGN_STYLE="Manual" \
              OTHER_CODE_SIGN_FLAGS="--options=runtime"
          else
            echo "Building with ad-hoc signing..."
            xcodebuild -scheme GoNhanh -configuration Release \
              -derivedDataPath build \
              CODE_SIGN_IDENTITY="-"
          fi

      # ============================================================
      # PACKAGE (Set version BEFORE signing)
      # ============================================================
      - name: Get version from latest release tag
        id: version
        run: |
          git fetch --tags
          # Find latest RELEASE tag (exclude pre-release tags with "-")
          LATEST_TAG=$(git tag --sort=-v:refname | grep -v '-' | head -1)
          LATEST_TAG="${LATEST_TAG:-v1.0.0}"
          BASE_VERSION="${LATEST_TAG#v}"
          # Bump patch version by 1 so pre-release is HIGHER than current release
          MAJOR=$(echo "$BASE_VERSION" | cut -d. -f1)
          MINOR=$(echo "$BASE_VERSION" | cut -d. -f2)
          PATCH=$(echo "$BASE_VERSION" | cut -d. -f3)
          NEXT_PATCH=$((PATCH + 1))
          BUILD_NUM="${GITHUB_RUN_NUMBER}"
          VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-pre.${BUILD_NUM}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Pre-release version: $VERSION (base: $LATEST_TAG)"

      - name: Set version in app
        run: |
          cd platforms/macos
          APP="build/Build/Products/Release/GoNhanh.app"
          V="${{ steps.version.outputs.version }}"
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $V" "$APP/Contents/Info.plist"
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $V" "$APP/Contents/Info.plist"

      # ============================================================
      # CODE SIGNING (After version is set)
      # ============================================================
      - name: Sign App with Entitlements
        env:
          SHOULD_SIGN: ${{ inputs.sign == true && env.APPLE_SIGNING_IDENTITY != '' }}
          CODE_SIGN_IDENTITY: ${{ env.APPLE_SIGNING_IDENTITY || '-' }}
        run: |
          cd platforms/macos
          APP="build/Build/Products/Release/GoNhanh.app"

          if [ "$SHOULD_SIGN" = "true" ]; then
            echo "Signing with Developer ID and hardened runtime..."
            codesign --force --deep --sign "$CODE_SIGN_IDENTITY" \
              --entitlements GoNhanh.entitlements.production \
              --options runtime \
              --timestamp \
              "$APP"
          else
            echo "Signing with ad-hoc identity..."
            codesign --force --deep --sign - \
              --entitlements GoNhanh.entitlements \
              "$APP"
          fi

          # Verify signature
          echo "Verifying signature..."
          codesign -vvv --deep --strict "$APP"
          echo "Signature verified successfully!"

      - name: Create DMG
        run: |
          cd platforms/macos
          APP="build/Build/Products/Release/GoNhanh.app"
          V="${{ steps.version.outputs.version }}"

          # Create DMG (version already set, app already signed)
          ../../scripts/release/dmg.sh "$APP" || {
            # Fallback: simple DMG if script fails
            hdiutil create -volname "GoNhanh" -srcfolder "$APP" -ov -format UDZO "build/GoNhanh-${V}.dmg"
          }

      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: GoNhanh-${{ steps.version.outputs.version }}-macOS
          path: platforms/macos/build/*.dmg
          retention-days: 14

      # ============================================================
      # SPARKLE APPCAST (Beta)
      # ============================================================
      - name: Generate Sparkle Appcast
        if: ${{ env.SPARKLE_PRIVATE_KEY != '' }}
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          cd platforms/macos
          V="${{ steps.version.outputs.version }}"
          DMG_FILE=$(ls build/*.dmg | head -1)
          DMG_NAME=$(basename "$DMG_FILE")
          DMG_SIZE=$(stat -f%z "$DMG_FILE")
          TAG_NAME="v${V}"
          DMG_URL="https://github.com/${{ github.repository }}/releases/download/${TAG_NAME}/${DMG_NAME}"

          # Download Sparkle tools
          mkdir -p /tmp/sparkle
          if [ ! -f /tmp/sparkle/bin/sign_update ]; then
            curl -sL "https://github.com/sparkle-project/Sparkle/releases/download/2.8.0/Sparkle-2.8.0.tar.xz" -o /tmp/sparkle.tar.xz
            tar xJf /tmp/sparkle.tar.xz -C /tmp/sparkle 2>/dev/null || \
              bsdtar xf /tmp/sparkle.tar.xz -C /tmp/sparkle 2>/dev/null || true
            rm -f /tmp/sparkle.tar.xz
          fi

          # Generate EdDSA signature
          ED_SIGNATURE=""
          if [ -f /tmp/sparkle/bin/sign_update ]; then
            KEY_FILE=$(mktemp)
            echo -n "$SPARKLE_PRIVATE_KEY" > "$KEY_FILE"
            SIGNATURE=$(/tmp/sparkle/bin/sign_update "$DMG_FILE" --ed-key-file "$KEY_FILE" 2>&1 || echo "")
            rm -f "$KEY_FILE"
            echo "sign_update output: $SIGNATURE"
            ED_SIGNATURE=$(echo "$SIGNATURE" | sed -n 's/.*edSignature="\([^"]*\)".*/\1/p')
          else
            echo "WARNING: sign_update not found, skipping EdDSA signature"
            ls -R /tmp/sparkle/ 2>/dev/null | head -30
          fi

          # Generate release notes from recent commits
          NOTES=$(git log --oneline -10 --pretty=format:"- %s" 2>/dev/null)
          # Generate release notes HTML file for Sparkle
          NOTES_HTML=$(echo "$NOTES" | sed \
            -e 's/&/\&amp;/g' \
            -e 's/^## \(.*\)/<h2>\1<\/h2>/' \
            -e 's/^### \(.*\)/<h3>\1<\/h3>/' \
            -e 's/^\*\*\(.*\)\*\*/<p><strong>\1<\/strong><\/p>/' \
            -e 's/^- \(.*\)/<li>\1<\/li>/' \
            -e '/^$/d')
          cat > build/release-notes.html << NOTES_EOF
          <html><body style="font-family:-apple-system,system-ui,sans-serif;font-size:13px;padding:8px">
          <h3>Recent Changes (Pre-release)</h3>
          ${NOTES_HTML}
          </body></html>
          NOTES_EOF
          sed -i '' 's/^          //' build/release-notes.html

          # Generate appcast.xml (same structure as release for full update flow testing)
          REPO="${{ github.repository }}"
          PUB_DATE=$(date -R)
          NOTES_URL="https://github.com/${REPO}/releases/download/${TAG_NAME}/release-notes.html"
          cat > build/appcast.xml << APPCAST_EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>GoNhanh</title>
              <link>https://github.com/${REPO}</link>
              <item>
                <title>Version ${V}</title>
                <sparkle:releaseNotesLink>${NOTES_URL}</sparkle:releaseNotesLink>
                <sparkle:version>${V}</sparkle:version>
                <sparkle:shortVersionString>${V}</sparkle:shortVersionString>
                <pubDate>${PUB_DATE}</pubDate>
                <enclosure url="${DMG_URL}" sparkle:edSignature="${ED_SIGNATURE}" length="${DMG_SIZE}" type="application/octet-stream"/>
              </item>
            </channel>
          </rss>
          APPCAST_EOF
          sed -i '' 's/^          //' build/appcast.xml

          echo "Generated appcast.xml for v${V}"
          cat build/appcast.xml

      - name: Create GitHub Pre-release
        if: ${{ env.SPARKLE_PRIVATE_KEY != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          cd platforms/macos
          V="${{ steps.version.outputs.version }}"
          TAG_NAME="v${V}"
          DMG_FILE=$(ls build/*.dmg | head -1)

          # Create release (marked latest so SUFeedURL /releases/latest/download/ works)
          gh release create "$TAG_NAME" \
            --title "GoNhanh $V (Pre-release)" \
            --notes "Pre-release build for testing Sparkle updates." \
            --latest \
            "$DMG_FILE" \
            build/appcast.xml \
            build/release-notes.html

          echo "Created pre-release: $TAG_NAME"

      # ============================================================
      # CLEANUP
      # ============================================================
      - name: Cleanup Keychain
        if: ${{ always() && inputs.sign == true && env.APPLE_SIGNING_IDENTITY != '' }}
        run: |
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true

  build-linux:
    # Manual trigger only (no auto PR build for Linux)
    if: ${{ github.event_name == 'workflow_dispatch' && (inputs.platform == 'linux' || inputs.platform == 'all') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: core

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            fcitx5 \
            libfcitx5core-dev \
            libfcitx5config-dev \
            libfcitx5utils-dev \
            fcitx5-modules-dev \
            extra-cmake-modules \
            libxkbcommon-dev \
            cmake \
            pkg-config

      - name: Build Rust core
        run: cargo build --manifest-path core/Cargo.toml --release

      - name: Build Fcitx5 addon
        run: |
          cd platforms/linux
          mkdir -p build && cd build
          cmake .. -DCMAKE_BUILD_TYPE=Release
          make -j$(nproc)

      - name: Get version from latest release tag
        id: version
        run: |
          git fetch --tags
          # Find latest RELEASE tag (exclude pre-release tags with "-")
          LATEST_TAG=$(git tag --sort=-v:refname | grep -v '-' | head -1)
          LATEST_TAG="${LATEST_TAG:-v1.0.0}"
          BASE_VERSION="${LATEST_TAG#v}"
          # Bump patch version by 1 so pre-release is HIGHER than current release
          MAJOR=$(echo "$BASE_VERSION" | cut -d. -f1)
          MINOR=$(echo "$BASE_VERSION" | cut -d. -f2)
          PATCH=$(echo "$BASE_VERSION" | cut -d. -f3)
          NEXT_PATCH=$((PATCH + 1))
          BUILD_NUM="${GITHUB_RUN_NUMBER}"
          VERSION="${MAJOR}.${MINOR}.${NEXT_PATCH}-pre.${BUILD_NUM}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Pre-release version: $VERSION (base: $LATEST_TAG)"

      - name: Package
        run: |
          V="${{ steps.version.outputs.version }}"
          cd platforms/linux
          mkdir -p dist
          cp build/src/libgonhanh.so dist/
          cp -r data/* dist/
          cp ../../core/target/release/libgonhanh_core.so dist/ || true
          tar -czvf "gonhanh-${V}-linux.tar.gz" -C dist .

      - name: Upload Linux artifact
        uses: actions/upload-artifact@v4
        with:
          name: GoNhanh-${{ steps.version.outputs.version }}-Linux
          path: platforms/linux/*.tar.gz
          retention-days: 14
